import "primitives/core.futil";
import "primitives/binary_operators.futil";
component main() -> () {
  cells {
    @external(1) path_ids = std_mem_d1(4, 15, 4);
    @external(1) paths_to_consider = std_mem_d1(1, 16, 4);
    @external(1) paths_on_node = std_mem_d1(1, 16, 4);
    @external(1) depth_output = std_mem_d1(4, 1, 1);
    @external(1) uniq_output = std_mem_d1(4, 1, 1);
    idx = std_reg(4);
    idx_adder = std_sadd(4);
    idx_neq = std_neq(4);
    path_id_reg = std_reg(4);
    uniq_and_reg_l = std_reg(1);
    uniq_and_reg_r = std_reg(1);
    depth = std_reg(4);
    depth_temp = std_reg(1);
    depth_pad = std_pad(1, 4);
    depth_adder = std_add(4);
    uniq = std_reg(4);
    uniq_and = std_and(1);
    uniq_pad = std_pad(1, 4);
    uniq_adder = std_add(4);
    uniq_idx = std_reg(4);
    unid_idx_neq = std_neq(4);
    uniq_idx_adder = std_sub(4);
  }
  wires {
    group init_idx {
      idx.in = 4'd0;
      idx.write_en = 1'd1;
      init_idx[done] = idx.done;
    }
    group load_path_id {
      path_ids.addr0 = idx.out;
      path_id_reg.in = path_ids.read_data;
      path_id_reg.write_en = 1'd1;
      load_path_id[done] = path_id_reg.done;
    }
    group inc_idx {
      idx_adder.left = idx.out;
      idx_adder.right = 4'd1;
      idx.in = idx_adder.out;
      idx.write_en = 1'd1;
      inc_idx[done] = idx.done;
    }
    comb group compare_idx {
      idx_neq.left = idx.out;
      idx_neq.right = 4'd14;
    }
    group load_consider_path {
      paths_to_consider.addr0 = path_id_reg.out;
      depth_temp.in = paths_to_consider.read_data;
      depth_temp.write_en = 1'd1;
      load_consider_path[done] = depth_temp.done;
    }
    group inc_depth {
      depth_adder.left = depth.out;
      depth_pad.in = depth_temp.out;
      depth_adder.right = depth_pad.out;
      depth.in = depth_adder.out;
      depth.write_en = 1'd1;
      inc_depth[done] = depth.done;
    }
    group write_depth {
      depth_output.addr0 = 1'd0;
      depth_output.write_data = depth.out;
      depth_output.write_en = 1'd1;
      write_depth[done] = depth_output.done;
    }
    group init_uniq_idx {
      uniq_idx.in = 4'd15;
      uniq_idx.write_en = 1'd1;
      init_uniq_idx[done] = uniq_idx.done;
    }
    comb group compare_uniq_idx {
      unid_idx_neq.left = uniq_idx.out;
      idx_neq.right = 4'd0;
    }
    group dec_uniq_idx {
      uniq_idx_adder.left = uniq_idx.out;
      uniq_idx_adder.right = 4'd1;
      uniq_idx.in = uniq_idx_adder.out;
      uniq_idx.write_en = 1'd1;
      dec_uniq_idx[done] = uniq_idx.done;
    }
    group update_pon {
      paths_on_node.addr0 = path_id_reg.out;
      paths_on_node.write_data = 1'd1;
      paths_on_node.write_en = 1'd1;
      update_pon[done] = paths_on_node.done;
    }
    group load_and_l {
      paths_on_node.addr0 = uniq_idx.out;
      uniq_and_reg_l.in = paths_on_node.read_data;
      uniq_and_reg_l.write_en = 1'd1;
      load_and_l[done] = uniq_and_reg_l.done;
    }
    group load_and_r {
      paths_to_consider.addr0 = uniq_idx.out;
      uniq_and_reg_r.in = paths_to_consider.read_data;
      uniq_and_reg_r.write_en = 1'd1;
      load_and_r[done] = uniq_and_reg_r.done;
    }
    group inc_uniq {
      uniq_and.left = uniq_and_reg_l.out;
      uniq_and.right = uniq_and_reg_r.out;
      uniq_adder.left = uniq.out;
      uniq_pad.in = uniq_and.out;
      uniq_adder.right = uniq_pad.out;
      uniq.in = uniq_adder.out;
      uniq.write_en = 1'd1;
      inc_uniq[done] = uniq.done;
    }
    group store_uniq {
      uniq_output.addr0 = 1'd0;
      uniq_output.write_data = uniq.out;
      uniq_output.write_en = 1'd1;
      store_uniq[done] = uniq_output.done;
    }
  }
  control {
    seq {
      init_idx;
      par {
        init_uniq_idx;
        while idx_neq.out with compare_idx {
          seq {
            load_path_id;
            par {
              inc_idx;
              seq {
                load_consider_path;
                inc_depth;
              }
              update_pon;
            }
          }
        }
      }
      load_path_id;
      load_consider_path;
      inc_depth;
      write_depth;
      update_pon;
      while unid_idx_neq.out with compare_uniq_idx {
        seq {
          par {
            load_and_l;
            load_and_r;
          }
          inc_uniq;
          dec_uniq_idx;
        }
      }
      store_uniq;
    }
  }
}
