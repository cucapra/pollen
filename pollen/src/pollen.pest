WHITESPACE = _{ " " }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Excludes type keywords
// keywords = _{ "if" | "elif" | "else" | "for" | "in" | "while" }

/* ----- Program ----- */
prog = { stmt+ }

/* ----- Types ----- */
atomic_type = { "int" | "bool" | "char" | 
                "Node" | "Step" | "Edge" | "Handle" | "Base" }

// String and Strand are not atomic types because they cannot be part of tuples
type = { atomic_type ~ ("*" ~ atomic_type)* | "String" | "Strand" }

/* Record types are not included because the user will never 
    need to explicitly define one */


/* ----- Literals ----- */
integer_lit = @{ ASCII_DIGIT+ }
bool_lit = _{ true_lit | false_lit }
    true_lit = { "true" }
    false_lit = { "false" }

single_quote = _{ "'" }
double_quote = _{ "\"" }
not_a_char = _{ "\\" | single_quote | double_quote }
char = _{ "\\" ~ (not_a_char | "n" | "t") | !(not_a_char) ~ ANY }
char_lit = @{ (single_quote ~ (!single_quote ~ char) ~ single_quote) }
string_lit = { double_quote ~ (char | single_quote)+ ~ double_quote }
// TODO: Try to find a way to use string_lit and strand_lit via precedence?

// array_lit = { "[" ~ expr? ~ ("," ~ expr)* ~ "]" }

literal = _{ integer_lit | bool_lit | char_lit | string_lit /* | array_lit */ }


/* ----- Expressions ----- */

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-" | "'" )+ }


binop = _{ add | sub | mult | div | modulo | exp | lt | gt | geq | leq | eq | neq |
          and | or }
    add = { "+" }
    sub = { "-" }
    mul = { "*" }
    div = { "/" }
    modulo = { "%" }
    exp = { "^" }
    lt = { "<" }
    gt = { ">" }
    geq = { "<=" }
    leq = { ">=" }
    eq = { "==" }
    neq = { "!=" }
    and = { "&&" }
    or = { "||" }

// TODO: Define precedence order for binops
binop_expr = { expr ~ binop ~ expr }

//uop = _{ not | neg }
    not = { "!" }
    neg = { "-" }
//uop = { uop ~ expr }

//call = { idendifier ~ "(" ~ expr? ~ ("," ~ expr)* ")" }
//array_access = { identifier ~ "[" ~ expr ~ "]"}
//record_access = { identifier ~ "." ~ identifier }

expr = { literal | identifier | binop_expr | "(" ~ expr ~ ")" | "[" ~ expr ~ "]" /* | uop_expr | call */ }


/* ----- Statements ---- */
decl = { type ~ identifier ~ ("=" ~ expr)? ~ ";"}
//assign = { (((identifier | array_access | record_access) ~ ("=" | "+=") ~ expr) | (identifier ~ "++")) ~ ";"}
// Function call
//call_stmt = { call ~ ";" }

//block = { "{" stmt+ "}" }

// Control Flow
//if_stmt = { "if " ~ expr ~ block ~ ("el"if_stmt)* ~ ("else" ~ block)? }
//while_stmt = { "}
//for_stmt = {}


//stmt = { decl | assign | call_stmt | if }

/* ----- Import ----- */
//import = {"use" ~ (!";" ~ ANY)+ ~ ";"} 