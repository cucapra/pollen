WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ ("//" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI)) 
            | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Excludes type keywords
// keywords = _{ "if" | "elif" | "else" | "for" | "in" | "while" }

/* ----- Program ----- */
file = { 
    SOI
    ~ stmt+
    ~ EOI
}

/* ----- Import ----- */
//import = {"use" ~ (!";" ~ ANY)+ ~ ";"} 

/* ----- Types ----- */
// Types that do not contain fields or method calls

atomic_typ = { "int" | "bool" | "char" | "Segment" | "Step" | "Edge" 
            | "Base" | "String" | "Strand" }

// tuple_typ = { atomic_typ ~ ("*" ~ atomic_typ)+ }

set_typ = { "Set<" ~ typ ~ ">" }

// String and Strand are not atomic types because they cannot be part of tuples
typ = _{ atomic_typ | set_typ /* | tuple_typ | typ ~ ( "[]"* ) */ }

/* Record types are not included because the user will never 
    need to explicitly define one */


/* ----- Literals ----- */
integer_lit = @{ ("+" | "-")? ~ ASCII_DIGIT+ }
bool_lit = _{ true_lit | false_lit }
    true_lit = { "true" }
    false_lit = { "false" }

single_quote = _{ "'" }
double_quote = _{ "\"" }
backslack = _{ "\\" }

backspace_chars = _{ back_backslash | back_tab | back_newline | back_single_quote 
                    | back_double_quote }
    back_backslash = { "\\\\" }
    back_tab = { "\\t" }
    back_newline = { "\\n" }
    back_single_quote = @{ "\\" ~ single_quote }
    back_double_quote = @{ "\\" ~ double_quote }

normal_char = { !backslack ~ ANY }

char = _{ backspace_chars | normal_char }
char_lit = ${ (single_quote ~ (!single_quote ~ char) ~ single_quote) }
string_lit = ${ double_quote ~ (!double_quote ~ char)* ~ double_quote }
// TODO: Try to find a way to use string_lit and strand_lit via precedence?

// array_lit = { "[" ~ expr? ~ ("," ~ expr)* ~ "]" }
record_lit = { typ ~ "{" ~
                identifier ~ ":" ~ expr  ~ 
                ("," ~ identifier ~ ":" ~ expr)* ~ "}"
             }
record_update_lit = { "{" ~ identifier ~ "with" ~
                identifier ~ ":" ~ expr  ~ 
                ("," ~ identifier ~ ":" ~ expr)* ~ "}"
             }

literal = _{ integer_lit | bool_lit | char_lit | string_lit 
            | record_lit | record_update_lit }


/* ----- Expressions ----- */

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_" | "-" | "'" )* }

binop = _{ add | sub | mult | div | modulo | geq | leq | lt | gt | eq | neq |
          and | or | field_access }
    add = { "+" }
    sub = { "-" }
    mult = { "*" }
    div = { "/" }
    modulo = { "%" }
    geq = { "<=" }
    leq = { ">=" }
    lt = { "<" }
    gt = { ">" }
    eq = { "==" }
    neq = { "!=" }
    and = { "&&" }
    or = { "||" }
    field_access = { "." }


// unary operator(s)
prefix = _{ not }
    not = { "!" }

call_begin = { "(" }

// postfix = { access }
//     access = { "." ~ field_id }
//         field_id = { identifier}
//         call_postfix = { "(" ~ expr? ~ ("," ~ expr)* ~ ")" }

// TODO: Parse something like path.first().steps. The call "operator" ("()")
//      isn't really a postfix operator because it can have expressions in the middle
// Distinguish between object initialization { type ~ "()" }, 
//                      method calls,        { expr ~ "." ~ identifier ~ call_postfix }
//                      function calls       { id ~ call_postfix}

//array_access = { identifier ~ "[" ~ expr ~ "]"}

obj_initialize = { typ ~ "()" }
func_call = { identifier ~ "(" ~ (expr ~ ("," ~ expr)*)? ~ ")" }

term = _{ literal | obj_initialize | func_call | identifier | "(" ~ expr ~ ")" | "[" ~ expr ~ "]" }

expr = { prefix* ~ term ~ (binop ~ prefix* ~ term ) * }


/* ----- Statements ---- */
decl = { identifier ~ ":" ~ typ ~ ("=" ~ expr)? ~ ";"}
assign = { identifier ~ "=" ~ expr ~ ";" }
// assign = { (((identifier | array_access | record_access) ~ ("=" | "+=") ~ expr) | (identifier ~ "++")) ~ ";"}
// Function call
// call_stmt = { call ~ ";" }

block = { "{" ~ stmt+ ~ "}" }

// Control Flow
if_stmt = { "if " ~ expr ~ block ~ ("elif" ~ expr ~ block)* ~ ("else" ~ block)? }
while_stmt = { "while" ~ expr ~ block }
for_stmt = { "for" ~ identifier ~ "in" ~ expr ~ block }

// Emit statements
emit_to = { "emit" ~ expr ~ "to" ~ identifier ~ ";" }

stmt = { decl | assign | block | if_stmt | while_stmt | for_stmt | emit_to }